<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Don&#39;t BB,show me the code!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://NicolasGui.github.io/"/>
  <updated>2017-12-18T13:18:47.000Z</updated>
  <id>http://NicolasGui.github.io/</id>
  
  <author>
    <name>Nicolas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web前端面试题-2017</title>
    <link href="http://NicolasGui.github.io/2017/12/18/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://NicolasGui.github.io/2017/12/18/web前端面试题/</id>
    <published>2017-12-18T07:02:29.000Z</published>
    <updated>2017-12-18T13:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a><center>基础部分</center></h2><h3 id="一个优秀的前端开发人员需要具备哪些特质？"><a href="#一个优秀的前端开发人员需要具备哪些特质？" class="headerlink" title="一个优秀的前端开发人员需要具备哪些特质？"></a>一个优秀的前端开发人员需要具备哪些特质？</h3><ul><li>学习能力</li><li>代码可维护性</li><li>代码规范性</li><li>解决问题的能力</li><li>沟通能力</li></ul><h3 id="常见的布局方式有哪些？"><a href="#常见的布局方式有哪些？" class="headerlink" title="常见的布局方式有哪些？"></a>常见的布局方式有哪些？</h3><ul><li>table布局</li><li>流式布局</li><li>弹性布局</li><li>响应式布局</li></ul><h3 id="css预加载的使用？"><a href="#css预加载的使用？" class="headerlink" title="css预加载的使用？"></a>css预加载的使用？</h3><p>less、sacc</p><h3 id="常见的解决浏览器兼容性问题的方式有哪些？"><a href="#常见的解决浏览器兼容性问题的方式有哪些？" class="headerlink" title="常见的解决浏览器兼容性问题的方式有哪些？"></a>常见的解决浏览器兼容性问题的方式有哪些？</h3><h3 id="html5有哪些新特性及其使用场合？如何解决兼容性问题"><a href="#html5有哪些新特性及其使用场合？如何解决兼容性问题" class="headerlink" title="html5有哪些新特性及其使用场合？如何解决兼容性问题"></a>html5有哪些新特性及其使用场合？如何解决兼容性问题</h3><h3 id="介绍一下标准的css的盒子模型？"><a href="#介绍一下标准的css的盒子模型？" class="headerlink" title="介绍一下标准的css的盒子模型？"></a>介绍一下标准的css的盒子模型？</h3><h3 id="如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？</h3><ul><li>1、设置margin:0 auto;width:。。。</li><li>2、确定容器的宽高，这里宽度是必须的，高度可以不设，设置外层的上外边距和左外边距分别是宽高的一半。<pre><code>实现居中关键在于 margin设置与 position:relative.</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.div &#123;</div><div class="line">    width:500px ;</div><div class="line">    height:300px;</div><div class="line">    margin: -150px 0 0 -250px;</div><div class="line">    position:relative;</div><div class="line">    left:50%;</div><div class="line">    top:50%;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><ul><li>3、position+transform<br>  c.position:absolute;<pre><code>top: 50%;left: 50%; /*只能把div定位在以红色圈为起点的位置，加上margin:-100px 0px 0px -100*/</code></pre></li></ul><h3 id="display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><blockquote><p>行框的排列会受到中间空白（回车空格等等）的影响，这些空白也会被应用样式，占据空间，所以会有间隔<br>    解决：设置ul的font-size为0，缺陷是必须重新在li中去设置字体大小</p></blockquote><h3 id="请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h3><ul><li>a.添加新的元素 、应用 clear：both;</li><li>b.父级定义 overflow: auto（注意：是父级div也就是这里的  div.outer） 一个对seo比较友好，另个hidden对seo不是太友好<br>  在IE6中还需要触发 hasLayout ，例如 zoom：1；</li><li>c.据说是最高大上的方法  :after<br>  方法：（注意：作用于浮动元素的父亲）IE6-7不支持:after，<br>  使用 zoom:1触发 hasLayout<br>  {zoom:1;}    /<em>==for IE6/7 Maxthon2==</em>/<br>  :after {clear:both;content:’.’;display:block;width: 0;height: 0;visibility:hidden;}</li><li>d.使用 br标签和其自身的 html属性,<br clear="all">  clear=“all | left | right | none” 属性</li><li>e.父元素也设置浮动</li><li>f.父元素设置display:table 盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</li></ul><h3 id="margin和padding分别适合什么场景使用？"><a href="#margin和padding分别适合什么场景使用？" class="headerlink" title="margin和padding分别适合什么场景使用？"></a>margin和padding分别适合什么场景使用？</h3><ul><li>何时应当使用margin：<br>（1）需要在border外侧添加空白时，<br>（2）空白处不需要有背景（色）时，<br>（3）上下相连的两个盒子之间的空白需要相互抵消时，比如15px+20px的margin，将得到20px的空白（注意地方见第三点）。</li><li>何时应当使用padding<br>（1）需要在border内侧添加空白时（往往是文字与边框距离的设置），<br>（2）空白处需要背景（色）时，<br>（3）上下相连的两个盒子之间的空白希望等于两者之和时，比如15px+20px的padding，将得到35px的空白。</li><li>margin使用时应该注意的地方</li><li>margin在垂直方向上相邻的值相同时会发生叠加，水平方向上相邻的值会相加。margin取负值时，在垂直方向上，两个元素的边界仍然会重叠。但是，此时一个为正值，一个为负值，并不是取其中较大的值，而是用正边界减去负边界的绝对值，也就是说，把正的边界值和负的边界值相加。</li></ul><h3 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容较低版本的IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容较低版本的IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容较低版本的IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容较低版本的IE？</h3><p>一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。</p><ul><li>优点：<br>  面对不同分辨率设备灵活性强<br>  能够快捷解决多设备显示适应问题</li><li>缺点：<br>  兼容各种设备工作量大，效率低下<br>  代码累赘，会出现隐藏无用的元素，加载时间加长<br>  其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果<br>  一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul><h3 id="有一个高度自适应的div。里面有2个div，一个高度100px，希望另一个填满剩下的高度？"><a href="#有一个高度自适应的div。里面有2个div，一个高度100px，希望另一个填满剩下的高度？" class="headerlink" title="有一个高度自适应的div。里面有2个div，一个高度100px，希望另一个填满剩下的高度？"></a>有一个高度自适应的div。里面有2个div，一个高度100px，希望另一个填满剩下的高度？</h3><blockquote><p>外层box-sizing: border-box; 同时设置padding: 100px 0 0；<br>    内层100像素高的元素向上移动100像素，或使用absolute定位防止占据空间；<br>    另一个元素直接height: 100%;<br>    外层position: relative；<br>    百分百自适应元素直接position: absolute; top: 100px; bottom: 0; left: 0</p></blockquote><h3 id="let、const、var的区别？"><a href="#let、const、var的区别？" class="headerlink" title="let、const、var的区别？"></a>let、const、var的区别？</h3><h3 id="nll和undefined的区别？"><a href="#nll和undefined的区别？" class="headerlink" title="nll和undefined的区别？"></a>nll和undefined的区别？</h3><ul><li>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</li><li>null表示”没有对象”，即该处不应该有值<br>  （1） 作为函数的参数，表示该函数的参数不是对象。<br>  （2） 作为对象原型链的终点。</li><li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义<br>  （1）变量被声明了，但没有赋值时，就等于undefined。<br>  （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>  （3）对象没有赋值的属性，该属性的值为undefined。<br>  （4）函数没有返回值时，默认返回undefined。</li></ul><h3 id="什么是闭包（closure）？为什么要用它？使用举例"><a href="#什么是闭包（closure）？为什么要用它？使用举例" class="headerlink" title="什么是闭包（closure）？为什么要用它？使用举例"></a>什么是闭包（closure）？为什么要用它？使用举例</h3><ul><li>闭包就是能够读取其他函数内部变量的函数</li><li>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</li><li>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br>闭包的用途：<br>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中<br>重用变量又不能造成全局污染<br>举例：朋友圈点赞、计数器</li></ul><h3 id="js代码中“use-strict”是什么意思？使用它区别是什么？"><a href="#js代码中“use-strict”是什么意思？使用它区别是什么？" class="headerlink" title="js代码中“use strict”是什么意思？使用它区别是什么？"></a>js代码中“use strict”是什么意思？使用它区别是什么？</h3><pre><code>进入”严格模式”的标志，老版本的浏览器会把它当作一行普通字符串，加以忽略将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。(严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。)将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;– 消除代码运行的一些不安全之处，保证代码运行的安全；– 提高编译器效率，增加运行速度；– 为未来新版本的Javascript做好铺垫。</code></pre><h3 id="js中有一个函数，执行对象查找时，永远不会去查找原型，这个函数是什么？"><a href="#js中有一个函数，执行对象查找时，永远不会去查找原型，这个函数是什么？" class="headerlink" title="js中有一个函数，执行对象查找时，永远不会去查找原型，这个函数是什么？"></a>js中有一个函数，执行对象查找时，永远不会去查找原型，这个函数是什么？</h3><blockquote><p>hasOwnProperty</p></blockquote><h3 id="js延迟加在的方式有哪些？"><a href="#js延迟加在的方式有哪些？" class="headerlink" title="js延迟加在的方式有哪些？"></a>js延迟加在的方式有哪些？</h3><ul><li><p>方式一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;id=my&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=”text/javascript”&gt;</div><div class="line">setTimeout(“document.getElementById(‘my&apos;).src=&apos;include/php100.php&apos;; “,3000);//延时3秒</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></li><li><p>方式二 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span id=”L4EVER”&gt;LOADING…&lt;/span&gt;</div><div class="line">&lt;span id=”AD_L4EVER”&gt;你的JS代码在这里!&lt;/span &gt;</div><div class="line">&lt;script&gt;L4EVER.innerHTML=AD_L4EVER.innerHTML;AD_L4EVER.innerHTML=”&quot;;&lt;/script&gt;</div></pre></td></tr></table></figure></li><li><p>方式三<br>js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度</p></li></ul><h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><h3 id="document-write和innerHTNML的区别？"><a href="#document-write和innerHTNML的区别？" class="headerlink" title="document.write和innerHTNML的区别？"></a>document.write和innerHTNML的区别？</h3><ul><li>1.document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。</li><li>2.innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。</li><li>3.两者都可动态包含外部资源如JavaScript文件<br>通过document.write插入<script></script>元素会自动执行其中的脚本；<br>大多数浏览器中，通过innerHTML插入<script></script>元素并不会执行其中的脚本<br>innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。</li></ul><h3 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h3><h3 id="引起内存泄漏的原因；"><a href="#引起内存泄漏的原因；" class="headerlink" title="引起内存泄漏的原因；"></a>引起内存泄漏的原因；</h3><h3 id="谈谈你对this的理解-this的使用场景、this绑定、this丢失"><a href="#谈谈你对this的理解-this的使用场景、this绑定、this丢失" class="headerlink" title="谈谈你对this的理解  this的使用场景、this绑定、this丢失"></a>谈谈你对this的理解  this的使用场景、this绑定、this丢失</h3><h3 id="js的数据类型都有哪些？区别？"><a href="#js的数据类型都有哪些？区别？" class="headerlink" title="js的数据类型都有哪些？区别？"></a>js的数据类型都有哪些？区别？</h3><ul><li>原始类型</li><li>引用类型</li></ul><h3 id="什么是Ajax，优缺点？使用场合？"><a href="#什么是Ajax，优缺点？使用场合？" class="headerlink" title="什么是Ajax，优缺点？使用场合？"></a>什么是Ajax，优缺点？使用场合？</h3><p>Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。</p><ul><li>优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量<br>避免用户不断刷新或者跳转页面，提高用户体验</li><li>缺点：<br>对搜索引擎不友好<br>要实现ajax下的前后退功能成本较大<br>可能造成请求数的增加<br>跨域问题限制</li></ul><h3 id="如何解析JSON？-至少3种办法，面试必问"><a href="#如何解析JSON？-至少3种办法，面试必问" class="headerlink" title="如何解析JSON？(至少3种办法，面试必问)"></a>如何解析JSON？(至少3种办法，面试必问)</h3><h3 id="js的typeof返回哪些数据类型？"><a href="#js的typeof返回哪些数据类型？" class="headerlink" title="js的typeof返回哪些数据类型？"></a>js的typeof返回哪些数据类型？</h3><h3 id="split-join-的区别？"><a href="#split-join-的区别？" class="headerlink" title="split()  join()的区别？"></a>split()  join()的区别？</h3><pre><code>join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，指定分隔符方法join(“#&quot;);其中#可以是任意与之相反的是split()方法：用于把一个字符串分割成字符串数组.</code></pre><h3 id="数组方法pop-push-unshift-shift"><a href="#数组方法pop-push-unshift-shift" class="headerlink" title="数组方法pop() push() unshift() shift()?"></a>数组方法pop() push() unshift() shift()?</h3><pre><code>push和pop方法，这两个方法只会对数组从尾部进行压入或弹出，而且是在原数组进行操作，任何的改动都是会影响到操作的数组。push(args)可以每次压入多个元素，并返回更新后的数组长度。pop()函数每次只会弹出最后一个结尾的元素，并返回弹出的元素，如果是对空组数调用pop()则返回undefined。 如果参数是数组则是将整个数组当做一个元素压入到原来的数组当中。并不会产生类似concat合并数组时产生的“拆分现象”unshift和shift这两个方法都是通过对数组的头部进行的操作，其他基本跟push和pop类似shift:从集合中把第一个元素删除，并返回这个元素的值。unshift: 在集合开头添加一个或更多元素，并返回新的长度push:在集合中添加元素，并返回新的长度pop:从集合中把最后一个元素删除，并返回这个元素的值</code></pre><h3 id="ES6的了解？"><a href="#ES6的了解？" class="headerlink" title="ES6的了解？"></a>ES6的了解？</h3><h3 id="js的本地对象，内置对象和宿主对象？"><a href="#js的本地对象，内置对象和宿主对象？" class="headerlink" title="js的本地对象，内置对象和宿主对象？"></a>js的本地对象，内置对象和宿主对象？</h3><ul><li>本地对象：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError官方定义好了的对象</li><li>内置对象： Global 和 Math，内置对象是本地对象的一种</li><li>宿主对象：所有的BOM和DOM对象都是宿主对象，是那些官方未定义，你自己构建的对象加上DOM和BOM对象组成的</li></ul><h3 id="列举所了解的前端框架并简述？"><a href="#列举所了解的前端框架并简述？" class="headerlink" title="列举所了解的前端框架并简述？"></a>列举所了解的前端框架并简述？</h3><p>详见vue官方文档第一页框架对比</p><h3 id="你如何对网站的文件和资源进行优化？期待的解决方法包括？"><a href="#你如何对网站的文件和资源进行优化？期待的解决方法包括？" class="headerlink" title="你如何对网站的文件和资源进行优化？期待的解决方法包括？"></a>你如何对网站的文件和资源进行优化？期待的解决方法包括？</h3><ul><li>A、文件合并，减少http请求，合并JavaScript和CSS文件、CSS Sprites、图像映射 （Image Map）和使用Data URI来编码图片</li><li>B、文件最小化/文件压缩，减少文件下载的体积；常用的工具是YUI Compressor</li><li>C、使用 CDN 托管，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定</li><li>D、缓存的使用（多个域名来提供缓存）</li><li>E、GZIP 压缩你的 JS 和 CSS 文件</li></ul><h3 id="js线程与进程的区别？"><a href="#js线程与进程的区别？" class="headerlink" title="js线程与进程的区别？"></a>js线程与进程的区别？</h3><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><h3 id="请解释一下什么是“语义化的-HTML”？"><a href="#请解释一下什么是“语义化的-HTML”？" class="headerlink" title="请解释一下什么是“语义化的 HTML”？"></a>请解释一下什么是“语义化的 HTML”？</h3><p>语义化的好处：</p><ul><li>1：去掉或样式丢失的时候能让页面呈现清晰的结构：</li><li>2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.</li><li>3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱</li><li>4.搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.</li><li>5.你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,    而只注重语义标记.</li><li>6.便于团队开发和维护语义化的HTML就是：标题用h1-h6，文字段落用p，列表用ul li，大致如此</li></ul><h3 id="为什么利用多个域名来提供网站资源会更有效？"><a href="#为什么利用多个域名来提供网站资源会更有效？" class="headerlink" title="为什么利用多个域名来提供网站资源会更有效？"></a>为什么利用多个域名来提供网站资源会更有效？</h3><p>浏览器同一时间可以从一个域名下载多少资源？你的浏览器能同时保持对一个域名的多少连接？</p><ul><li><ol><li>CDN缓存更方便</li></ol></li><li><ol><li>突破浏览器并发限制 (你随便挑一个 G家的 url: h ttps://lh4.googleusercontent.com/- si4dh2myPWk/T81YkSi__AI/AAAAAAAAQ5o/LlwbBRpp58Q/w497-h373/IMG_20120603_163233.jpg, 把前面的 lh4换成 lh3,lh6 啥的，都照样能够访问，像地图之类的需要大量并发下载图片的站点，这个非常重要。)</li></ol></li><li><ol><li>Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。。。<br>还有另外两个非常规原因:</li></ol></li><li><ol><li>对于UGC的内容和主站隔离，防止不必要的安全问题( 上传js窃取主站cookie之类的) 。<br>正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。</li></ol></li><li><ol><li>数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事. ^_^ 这个可能被用的不多。</li></ol></li></ul><p>PS: 关于Cookie的问题，带宽是次要的，安全隔离才是主要的。<br>关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走 https的话，还有要多买证书和部署的问题，^_^。</p><h3 id="如果你参与到一个项目中，发现他们使用-Tab-来缩进代码，但是你喜欢空格，你会怎么做"><a href="#如果你参与到一个项目中，发现他们使用-Tab-来缩进代码，但是你喜欢空格，你会怎么做" class="headerlink" title="如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做"></a>如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做</h3><ul><li>1.建议这个项目使用像 EditorConfig 之类的规范</li><li>2.为了保持一致性，接受项目原有的风格</li><li>3.直接使用 VIM 的 retab 命令</li></ul><h3 id="data-属性的作用是什么？"><a href="#data-属性的作用是什么？" class="headerlink" title="data-属性的作用是什么？"></a>data-属性的作用是什么？</h3><p>data-为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;div data-author=&quot;david&quot; data-time=&quot;2011-06-20&quot; data-comment-num=&quot;10&quot;&gt;...&lt;/div&gt;</div><div class="line">div.dataset.commentNum; // 10</div></pre></td></tr></table></figure></code></pre><p>需要注意的是，data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持.dataset属性，测试的浏览器中只有Chrome和Opera支持。</p><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><ul><li>sessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</li><li>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。</li><li>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</li><li>cookies会发送到服务器端。其余两个不会。</li><li>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。<br>　　Firefox每个域名cookie限制为50个。<br>　　Opera每个域名cookie限制为30个。</li><li>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。<br>　　Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。<br>　　InternetExplorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。</li></ul><h3 id="描述下-“reset”-CSS-文件的作用和使用它的好处。"><a href="#描述下-“reset”-CSS-文件的作用和使用它的好处。" class="headerlink" title="描述下 “reset” CSS 文件的作用和使用它的好处。"></a>描述下 “reset” CSS 文件的作用和使用它的好处。</h3><pre><code>因为浏览器的品种很多，每个浏览器的默认样式也是不同的，所以定义一个css reset可以使各浏览器的默认样式统一。</code></pre><h3 id="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"><a href="#如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？" class="headerlink" title="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"></a>如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？</h3><ul><li>1.display:none;的缺陷<br>搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略<br>屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</li><li><ol><li>visibility: hidden ;的缺陷<br>这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间</li></ol></li><li>3.overflow:hidden;一个比较合理的方法<pre><code>.texthidden { display:block;/*统一转化为块级元素*/ overflow: hidden; width: 0; height: 0; }就像上面的一段CSS所展示的方法，将宽度和高度设定为0，然后超过部分隐藏，就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的。</code></pre></li></ul><h3 id="解释下事件代理？"><a href="#解释下事件代理？" class="headerlink" title="解释下事件代理？"></a>解释下事件代理？</h3><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。<br>     当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。<br>     事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function getEventTarget(e) &#123;</div><div class="line">e = e || window.event;</div><div class="line">return e.target || e.srcElement;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="解释下原型继承的原理？"><a href="#解释下原型继承的原理？" class="headerlink" title="解释下原型继承的原理？"></a>解释下原型继承的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function getProperty(obj, prop) &#123;</div><div class="line">if (obj.hasOwnProperty(prop)) &#123;</div><div class="line">return obj[prop];</div><div class="line">&#125;else if (obj.__proto__ !== null) &#123;</div><div class="line">return getProperty(obj.__proto__, prop);</div><div class="line">&#125;else&#123;</div><div class="line">return undefined;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="实操部分"><a href="#实操部分" class="headerlink" title="实操部分"></a><center>实操部分</center></h2><ul><li>用原型链的方式给Array对象添加一个数组去重的方法？</li><li>定义一个方法，对所有传入的数字参数的第三位小数进行四舍五入，使得返回值保留两位小数，不够的补0</li><li>定义一个方法，实现阶乘</li><li>定义一段代码，页面载入完成1分钟后非缓存模式刷新当前页面</li><li>把Object的实例化对象A、B、C合并 赋值给对象C</li><li>写一个function 清楚字符串前后的空格（兼容所有浏览器）</li><li>获取指定范围内N个不重复的随机数</li><li>对事件的理解，如何阻止事件默认行为和事件冒泡？<br>  默认行为：<pre><code>event.preventDefault();</code></pre>  冒泡：<pre><code>event.stopPropregation();event.cancelBubble();</code></pre></li><li>实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？</li></ul><blockquote><p>用cookie或者localStorage来记录应用的状态即可，刷新页面时读取一下这个状态，然后发送相应ajax请求来改变页面即可<br>HTML5里引用了新的API，就是history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的<br>虽然ajax可以无刷新改变页面内容，但无法改变页面URL<br>其次为了更好的可访问性，内容发生改变后，改变URL的hash。但是hash的方式不能很好的处理浏览器的前进、后退等问题<br>有的浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变<br>再有，ajax的使用对搜索引擎很不友好，往往蜘蛛爬到的区域是空的<br>为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState<br>可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。<br>pushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。<br>如何调用？<br>var state = {    title: title,    url: options.url,    otherkey: othervalue};window.history.pushState(state, document.title, url);<br>state对象除了要title和url之外，也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。<br>如何响应浏览器的前进、后退操作<br>window对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。<br>window.addEventListener(‘popstate’, function(e){ if (history.state){    var state = e.state; //do something(state.url, state.title); }}, false);<br>这样就可以结合ajax和pushState完美的进行无刷新浏览了。</p></blockquote><h2 id="Web前端优化面试要点"><a href="#Web前端优化面试要点" class="headerlink" title="Web前端优化面试要点"></a><center>Web前端优化面试要点</center></h2><ul><li>（1）. CSS Sprites 合成图片<br>优点：减少HTTP请求次数，图片合成后总大小变小，加快加载<br>缺点：不利于后期修改，每次修改单个图片都要重新合成一次；不利于代码语义化<br>折中：按照使用频率、功能类型的不同合成几个级别不同的图片</li><li>（2）. 合并css, js文件<br>优点：减少HTTP请求次数，加快加载<br>缺点：牺牲了代码组织结构，使单个文件内部混乱<br>折中：适当分开，尽量合并</li><li>（3）. 压缩文件大小<br>代码文件：用压缩工具压缩，去掉空白、无用、重复代码； 图片文件：降低分辨率、改变格式（PNG优先）、压缩图片质量等，也可以使用专业的压缩工具<br>优点：缩小体积，加快加载<br>缺点：没有明显缺点，如果一定要说的话，压缩后的代码可读性差（不过一般都会留一份压缩前的源码）</li><li>（4）. 结构（HTML）样式（CSS）行为（JS）分离<br>优点：<br>使项目结构更清晰，易于维护，易于对各部分进行单独的处理而不影响其他部分。<br>提高代码可复用性<br>浏览器会单独缓存css, js文件，加快加载<br>缺点：有缺点吗？对了，demo之类的小项目可以不用分离了，多此一举</li><li>（5）. CSS放在页面开头（head内部），JS放在页面末尾（body之前）<br>DOM树的生成是受JS代码执行的影响的，JS代码会“阻塞”页面的渲染，详细请读《JavaScript权威指南》(P320-P322)</li><li>（6）. 使用CDN（内容发布网络）<br>优点：CDN会帮你找到距离用户电脑最近的服务器上的资源文件，更够更快速地传到相应的浏览器上。<br>缺点：</li></ul><p>不利于离线开发，也无法对远程的资源进行控制（比如添加一些自定义的修改）<br>有些CDN服务在某些国家和地区无法访问，比如在天朝访问使用了google cdn的网站时就会出现很多问题</p><ul><li>（7）. 尽量减少浏览器reflow<br>这里设计关于Reflow和Repaint的知识。Reflow简单来讲就是浏览器重新渲染页面布局，这可能是由于一个很小的节点的改变引发的，作用很小，代价很大，所以应尽量避免。<br>措施：<br>减小不必要的DOM树深度，也就是说，不必要的话，你的DOM树不要太多层了，其中一层的布局变化将引起整棵树的重新渲染。<br>尽量使用对class进行操作来动态改变元素样式，而不是直接对元素css进行更改。<br>需要使用动画的元素应将其position设置为absolute或者fixed，使其脱离文档流。<br>避免过于复杂的css选择器，尤其要避免使用过多后代选择器，太多层CPU开销很大。<br>不要用表格进行页面布局，表格式牵一发动全身的布局方式。<br>不要用css表达式</li><li>（8）. 使用<link>，避免使用@import加载css<br>优点：@import的css文件无法同步并行加载，必须等一个加载完才能加载下一个，势必造成速度问题，而link引用的多个stylesheet则可以同步并行加载，速度更快<br>缺点：暂时没想到</li><li>（9）. 尽量少使用css filter达到滤镜效果，可以用png图片</li><li>（10）. 能用HTML做的事，不要让css、js来做，能用css做的事，不要让js来做</li><li>（11）. 使用iconfont代替图片图标<h3 id="如何解决跨域问题？原理？"><a href="#如何解决跨域问题？原理？" class="headerlink" title="如何解决跨域问题？原理？"></a>如何解决跨域问题？原理？</h3><blockquote><p>JSONP：<br>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。<br>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。<br>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。<br>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function createJs(sUrl)&#123;</div><div class="line"></div><div class="line">        var oScript = document.createElement(&apos;script&apos;);</div><div class="line">        oScript.type = &apos;text/javascript&apos;;</div><div class="line">        oScript.src = sUrl;</div><div class="line">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createJs(&apos;jsonp.js&apos;);</div><div class="line"></div><div class="line">    box(&#123;</div><div class="line">       &apos;name&apos;: &apos;test&apos;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    function box(json)&#123;</div><div class="line">        alert(json.name);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。<br>通过修改document.domain来跨子域<br>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域<br>主域相同的使用document.domain<br>使用window.name来进行跨域<br>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的<br>使用HTML5中新引进的window.postMessage方法来跨域传送数据<br>还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><p>(1).数据体积方面。<br>JSON相对于XML来讲，数据的体积小，传递的速度更快些。<br>(2).数据交互方面。<br>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。<br>(3).数据描述方面。<br>JSON对数据的描述性比XML较差。<br>(4).传输速度方面。<br>JSON的速度要远远快于XML。<br>TCP协议<br>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂。<br>TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。<br>UDP协议</p><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。<br>TCP协议和UDP协议的区别<br>(1).TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接；<br>(2).TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付；<br>(3).TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；<br>(4).每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；<br>(5).TCP首部开销20字节；UDP的首部开销小，只有8个字节；<br>(6).TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。</p><h3 id="Ajax是什么？Ajax常用的技术列举几个？Ajax的缺点有什么？"><a href="#Ajax是什么？Ajax常用的技术列举几个？Ajax的缺点有什么？" class="headerlink" title="Ajax是什么？Ajax常用的技术列举几个？Ajax的缺点有什么？"></a>Ajax是什么？Ajax常用的技术列举几个？Ajax的缺点有什么？</h3><p>ajax的全称是AsynchronousJavascript+XML，是指一种创建交互式网页应用的网页开发技术。即异步传输+js+xml。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。<br>AJAX常用的技术</p><ul><li>基于 web 标准（standards-based presentation）XHTML+CSS的表示；</li><li>使用 DOM（Document Object Model）进行动态显示及交互；</li><li>使用 XML 和 XSLT 进行数据交换及相关操作；</li><li>使用 XMLHttpRequest 进行异步数据查询、检索；</li><li>使用 JavaScript 将所有的东西绑定在一起</li><li>类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。</li></ul><p>AJAX的优缺点<br>1.优点</p><ul><li>无刷新更新数据：AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。</li><li>异步与服务器通信：AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。</li><li>前端和后端负载平衡：AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。</li><li>基于标准被广泛支持：AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。</li><li>界面与应用分离：Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。<br>2.缺点</li><li>对浏览器机制的破坏：AJAX干掉了Back和History功能，在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。</li><li>AJAX的安全问题：Ajax技术就如同对企业数据建立了一个直接通道，这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。</li><li>对搜索引擎支持较弱：如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。</li><li>破坏程序的异常处理机制</li><li>违背URL和资源定位的初衷：如果采用了Ajax技术，也许不同的人在同一个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。<br>AJAX不能很好支持移动设备。</li></ul><h3 id="对前端模块化的认识"><a href="#对前端模块化的认识" class="headerlink" title="对前端模块化的认识"></a>对前端模块化的认识</h3><ul><li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</li><li>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</li><li>AMD 是提前执行，CMD 是延迟执行。</li><li>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。</li><li>CMD模块方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    define(function(require, exports, module) &#123;</div><div class="line">      // 模块代码</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h3><ul><li>标记清除（mark and sweep）</li><li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</li><li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了。</li></ul><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>队列先进先出，栈先进后出。<br>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除<br>栈和堆的区别？</p><ul><li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li><li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li><li>栈（数据结构）：一种先进后出的数据结构。</li></ul><h3 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h3><p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p><ul><li>webpack的两大特色：<br>（1）.code splitting（可以自动完成）<br>（2）.loader 可以处理各种类型的静态文件，并且支持串联操作</li><li>webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：<br>（1）. 对 CommonJS 、 AMD 、ES6的语法做了兼容<br>（2）. 对js、css、图片等资源文件都支持打包<br>（3）. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持<br>（4）. 有独立的配置文件webpack.config.js<br>（5）. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间<br>（6）. 支持 SourceUrls 和 SourceMaps，易于调试<br>（7）. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活<br>（8）.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li></ul><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。<br>默认HTTP的端口号为80，HTTPS的端口号为443。<br>为什么HTTPS安全<br>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性。</p><h2 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h2><p>sql注入原理<br>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br>总的来说有以下几点：</p><ul><li>（1）.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li><li>（2）.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li><li>（3）.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>（4）.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</li></ul><h3 id="javascript继承的6种方法"><a href="#javascript继承的6种方法" class="headerlink" title="javascript继承的6种方法"></a>javascript继承的6种方法</h3><p>（1）原型链继承<br>（2）借用构造函数继承<br>（3）组合继承(原型+借用构造)<br>（4）原型式继承<br>（5）寄生式继承<br>（6）寄生组合式继承</p><h3 id="Node-js的适用场景？"><a href="#Node-js的适用场景？" class="headerlink" title="Node.js的适用场景？"></a>Node.js的适用场景？</h3><ul><li>高并发、聊天、实时消息推送</li><li>说说严格模式的限制</li><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li><li>设立”严格模式”的目的，主要有以下几个：</li><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li><li>注：经过测试IE6,7,8,9均不支持严格模式。</li></ul><h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ul><h3 id="jQuery-中如何将数组转化为json字符串，然后再转化回来？"><a href="#jQuery-中如何将数组转化为json字符串，然后再转化回来？" class="headerlink" title="jQuery 中如何将数组转化为json字符串，然后再转化回来？"></a>jQuery 中如何将数组转化为json字符串，然后再转化回来？</h3><p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    $.fn.stringifyArray = function(array) &#123;</div><div class="line">        return JSON.stringify(array)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $.fn.parseArray = function(array) &#123;</div><div class="line">        return JSON.parse(array)</div><div class="line">    &#125; </div><div class="line"></div><div class="line">//然后调用：</div><div class="line">$(&quot;&quot;).stringifyArray(array)</div></pre></td></tr></table></figure><h3 id="针对-jQuery-的优化方法？"><a href="#针对-jQuery-的优化方法？" class="headerlink" title="针对 jQuery 的优化方法？"></a>针对 jQuery 的优化方法？</h3><ul><li>基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</li><li>频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。<br>比如：var str=$(“a”).attr(“href”);</li><li>for (var i = size; i &lt; arr.length; i++) {}<br>for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：<br>for (var i = size, length = arr.length; i &lt; length; i++) {}</li></ul><h3 id="如何编写高性能的Javascript？"><a href="#如何编写高性能的Javascript？" class="headerlink" title="如何编写高性能的Javascript？"></a>如何编写高性能的Javascript？</h3><ul><li>使用 DocumentFragment 优化多次 append</li><li>通过模板元素 clone ，替代 createElement</li><li>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</li><li>使用三目运算符替代条件分支</li><li>需要不断执行的时候，优先考虑使用 setInterval</li></ul><h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><p>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p><h3 id="对Node的优点和缺点提出了自己的看法？"><a href="#对Node的优点和缺点提出了自己的看法？" class="headerlink" title="对Node的优点和缺点提出了自己的看法？"></a>对Node的优点和缺点提出了自己的看法？</h3><ul><li><p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p></li><li><p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。<br>写出几种IE6 BUG的解决方法</p><pre><code>（1）.双边距BUG float引起的 使用display （2）.3像素问题 使用float引起的 使用dislpay:inline -3px （3）.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active （4）.Ie z-index问题 给父级添加position:relative （5）.Png 透明 使用js代码 改 （6）.Min-height 最小高度 ！Important 解决’ （7）.select 在ie6下遮盖 使用iframe嵌套 （8）.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用 </code></pre><p>over:hidden,zoom:0.08 line-height:1px）</p></li></ul><h3 id="AJAX应用和传统Web应用有什么不同"><a href="#AJAX应用和传统Web应用有什么不同" class="headerlink" title="AJAX应用和传统Web应用有什么不同"></a>AJAX应用和传统Web应用有什么不同</h3><p>在传统的Javascript编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击“Submit”按钮来发送或者接受数据信息，然后等待服务器响应请求，页面重新加载。因为服务器每次都会返回一个新的页面，所以传统的web应用有可能很慢而且用户交互较差。<br>使用AJAX技术，就可以使Javascript通过XMLHttpRequest对象直接与服务器进行交互。通过HTTP Request，一个web页面可以发送一个请求到web服务器并且接受web服务器返回的信息(不用重新加载页面)，展示给用户的还是同一个页面，但是只实现页面的局部刷新，从而提高体验度<br>平时如何管理你的项目？</p><ul><li>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li><li>页面进行标注（例如 页面 模块 开始和结束）；</li><li>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</li><li>JS 分文件夹存放 命名以该JS功能为准的英文翻译。</li><li>图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</li></ul><h3 id="说一下什么是javascript的同源策略？"><a href="#说一下什么是javascript的同源策略？" class="headerlink" title="说一下什么是javascript的同源策略？"></a>说一下什么是javascript的同源策略？</h3><p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><ul><li>为什么要有同源限制？<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li><li>缺点：<br>现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</li></ul><h3 id="说说最近最流行的一些东西吧？常去哪些网站？"><a href="#说说最近最流行的一些东西吧？常去哪些网站？" class="headerlink" title="说说最近最流行的一些东西吧？常去哪些网站？"></a>说说最近最流行的一些东西吧？常去哪些网站？</h3><p>Node.js、Mongodb、npm、MVVM、MEAN、three.js、vue.js、react。。。。。</p><h3 id="你遇到过比较难的技术问题是？你是如何解决的？"><a href="#你遇到过比较难的技术问题是？你是如何解决的？" class="headerlink" title="你遇到过比较难的技术问题是？你是如何解决的？"></a>你遇到过比较难的技术问题是？你是如何解决的？</h3><h3 id="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"><a href="#常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？" class="headerlink" title="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"></a>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3><h3 id="页面重构怎么操作？"><a href="#页面重构怎么操作？" class="headerlink" title="页面重构怎么操作？"></a>页面重构怎么操作？</h3><h3 id="列举IE-与其他浏览器不一样的特性？"><a href="#列举IE-与其他浏览器不一样的特性？" class="headerlink" title="列举IE 与其他浏览器不一样的特性？"></a>列举IE 与其他浏览器不一样的特性？</h3><h3 id="99-的网站都需要被重构是那本书上写的？"><a href="#99-的网站都需要被重构是那本书上写的？" class="headerlink" title="99%的网站都需要被重构是那本书上写的？"></a>99%的网站都需要被重构是那本书上写的？</h3><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><h3 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><h3 id="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"><a href="#除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？" class="headerlink" title="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"></a>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3><h3 id="你常用的开发工具是什么，为什么？"><a href="#你常用的开发工具是什么，为什么？" class="headerlink" title="你常用的开发工具是什么，为什么？"></a>你常用的开发工具是什么，为什么？</h3><h3 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p><ul><li>1、实现界面交互</li><li>2、提升用户体验</li><li>3、有了Node.js，前端可以实现服务端的一些事情</li></ul><h3 id="前端是最贴近用户的程序员，前端的能力就是能让产品从-90分进化到-100-分，甚至更好，"><a href="#前端是最贴近用户的程序员，前端的能力就是能让产品从-90分进化到-100-分，甚至更好，" class="headerlink" title="前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，"></a>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</h3><ul><li>参与项目，快速高质量完成实现效果图，精确到1px；</li><li>与团队成员，UI设计，产品经理的沟通；</li><li>做好的页面结构，页面重构和用户体验；</li><li>处理hack，兼容、写出优美的代码格式；</li><li>针对服务器的优化、拥抱最新前端技术。</li></ul><h3 id="为什么异步加载JS文件？加载方式？"><a href="#为什么异步加载JS文件？加载方式？" class="headerlink" title="为什么异步加载JS文件？加载方式？"></a>为什么异步加载JS文件？加载方式？</h3><ul><li>平时常用的引入JS方式，是同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，也就是说，浏览器在下载或执行该js代码块时，后面的标签不会被解析。</li><li>异步加载（async）JS文件，允许页面内容异步加载，仅适用于外部脚本。</li><li>延迟加载（defer） 属性规定是否对脚本执行进行延迟，直到页面加载为止。</li></ul><h3 id="你还有什么问题要问吗"><a href="#你还有什么问题要问吗" class="headerlink" title="你还有什么问题要问吗?"></a>你还有什么问题要问吗?</h3><ul><li>问目前在做的项目</li><li>使用的技术</li><li>晋升机制</li></ul><h2 id="NG部分"><a href="#NG部分" class="headerlink" title="NG部分"></a><center>NG部分</center></h2><h3 id="ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？"><a href="#ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？" class="headerlink" title="ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？"></a>ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？</h3><p>会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）。</p><h3 id="ng-click-中写的表达式，能使用-JS-原生对象上的方法吗？"><a href="#ng-click-中写的表达式，能使用-JS-原生对象上的方法吗？" class="headerlink" title="ng-click 中写的表达式，能使用 JS 原生对象上的方法吗？"></a>ng-click 中写的表达式，能使用 JS 原生对象上的方法吗？</h3><p>不止是 ng-click 中的表达式，只要是在页面中，都不能直接调用原生的 JS 方法，因为这些并不存在于与页面对应的 Controller 的 $scope 中。<br>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;parseInt(55.66)&#125;&#125;&lt;p&gt;</div></pre></td></tr></table></figure><p>会发现，什么也没有显示。<br>但如果在 $scope 中添加了这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.parseInt = function(x)&#123;</div><div class="line">    return parseInt(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样自然是没什么问题了。<br>对于这种需求，使用一个 filter 或许是不错的选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;13.14 | parseIntFilter&#125;&#125;&lt;/p&gt;</div><div class="line"></div><div class="line">app.filter(&apos;parseIntFilter&apos;, function()&#123;</div><div class="line">    return function(item)&#123;</div><div class="line"> return parseInt(item);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="angular-的数据绑定采用什么机制？详述原理"><a href="#angular-的数据绑定采用什么机制？详述原理" class="headerlink" title="angular 的数据绑定采用什么机制？详述原理"></a>angular 的数据绑定采用什么机制？详述原理</h3><p>脏检查机制。<br>双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。<br>原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。<br>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button ng-click=&quot;val=val+1&quot;&gt;increase 1&lt;/button&gt;</div></pre></td></tr></table></figure><p>click 时会产生一次更新的操作（至少触发两次 $digest 循环）<br>按下按钮<br>浏览器接收到一个事件，进入到 angular context<br>$digest 循环开始执行，查询每个 $watch 是否变化<br>由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环<br>新的 $digest 循环未检测到变化<br>浏览器拿回控制器，更新 $scope.val 新值对应的 dom<br>$digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。<br>两个平级界面块 a 和 b，如果 a 中触发一个事件，有哪些方式能让 b 知道？详述原理<br>这个问题换一种说法就是，如何在平级界面模块间进行通信。有两种方法，一种是共用服务，一种是基于事件。<br>共用服务<br>在 Angular 中，通过 factory 可以生成一个单例对象，在需要通信的模块 a 和 b 中注入这个对象即可。<br>基于事件<br>这个又分两种方式<br>第一种是借助父 controller。在子 controller 中向父 controller 触发（$emit）一个事件，然后在父 controller 中监听（$on）事件，再广播（$broadcast）给子 controller ，这样通过事件携带的参数，实现了数据经过父 controller，在同级 controller 之间传播。<br>第二种是借助 $rootScope。每个 Angular 应用默认有一个根作用域 $rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。所以，如果子控制器直接使用 $rootScope 广播和接收事件，那么就可实现同级之间的通信。<br>逻辑代码的拆分<br>作为一个 MVVM 框架，Angular 应用本身就应该按照 模型，视图模型（控制器），视图来划分。<br>这里逻辑代码的拆分，主要是指尽量让 controller 这一层很薄。提取共用的逻辑到 service 中 （比如后台数据的请求，数据的共享和缓存，基于事件的模块间通信等），提取共用的界面操作到 directive 中（比如将日期选择、分页等封装成组件等），提取共用的格式化操作到 filter 中等等。<br>在复杂的应用中，也可以为实体建立对应的构造函数，比如硬盘（Disk）模块，可能有列表、新建、详情这样几个视图，并分别对应的有 controller，那么可以建一个 Disk 构造函数，里面完成数据的增删改查和验证操作，有跟 Disk 相关的 controller，就注入 Disk 构造器并生成一个实例，这个实例就具备了增删改查和验证方法。这样既层次分明，又实现了复用（让 controller 层更薄了）。<br>angular 应用常用哪些路由库，各自的区别是什么？<br>Angular1.x 中常用 ngRoute 和 ui.router，还有一种为 Angular2 设计的 new router（面向组件）。后面那个没在实际项目中用过，就不讲了。<br>无论是 ngRoute 还是 ui.router，作为框架额外的附加功能，都必须以 模块依赖 的形式被引入。<br>区别<br>ngRoute 模块是 Angular 自带的路由模块，而 ui.router 模块是基于 ngRoute模块开发的第三方模块。<br>ui.router 是基于 state （状态）的， ngRoute 是基于 url 的，ui.router模块具有更强大的功能，主要体现在视图的嵌套方面。<br>使用 ui.router 能够定义有明确父子关系的路由，并通过 ui-view 指令将子路由模版插入到父路由模板的 <div ui-view=""></div> 中去，从而实现视图嵌套。而在 ngRoute 中不能这样定义，如果同时在父子视图中 使用了 <div ng-view=""></div> 会陷入死循环。<br>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ngRoute</div><div class="line">var app = angular.module(&apos;ngRouteApp&apos;, [&apos;ngRoute&apos;]);</div><div class="line">app.config(function($routeProvider)&#123;</div><div class="line">    $routeProvider</div><div class="line">        .when(&apos;/main&apos;, &#123;</div><div class="line">            templateUrl: &quot;main.html&quot;,</div><div class="line">            controller: &apos;MainCtrl&apos;</div><div class="line">        &#125;)</div><div class="line">        .otherwise(&#123; redirectTo: &apos;/tabs&apos; &#125;);</div><div class="line">ui.router</div><div class="line">var app = angular.module(&quot;uiRouteApp&quot;, [&quot;ui.router&quot;]);</div><div class="line">app.config(function($urlRouterProvider, $stateProvider)&#123;</div><div class="line">    $urlRouterProvider.otherwise(&quot;/index&quot;);</div><div class="line">    $stateProvider</div><div class="line">        .state(&quot;Main&quot;, &#123;</div><div class="line">            url: &quot;/main&quot;,</div><div class="line">            templateUrl: &quot;main.html&quot;,</div><div class="line">            controller: &apos;MainCtrl&apos;</div><div class="line">        &#125;)</div></pre></td></tr></table></figure><h3 id="如何看待angular2"><a href="#如何看待angular2" class="headerlink" title="如何看待angular2"></a>如何看待angular2</h3><p>相比 Angular1.x，Angular2的改动很大，几乎算是一个全新的框架。<br>基于 TypeScript（可以使用 TypeScript 进行开发），在大型项目团队协作时，强语言类型更有利。<br>组件化，提升开发和维护的效率。<br>还有 module 支持动态加载，new router，promise的原生支持等等。</p><h3 id="什么是angular的广播与事件"><a href="#什么是angular的广播与事件" class="headerlink" title="什么是angular的广播与事件"></a>什么是angular的广播与事件</h3><pre><code>AngularJS 中在触发事件和发送广播时，都可以传递参数，可以通过这一特性，来实现数据的共享。与事件和广播相关的，共有三个方法，分别是：（1）.$emit()：触发事件，它可以向上传递数据，比如，子控制器向父控制器，还有控制器向 $rootScope（2）.$broadcast()：发送广播，它可以向下传递数据，比如，父控制器向子控制器传递数据，或者 $rootScope 向任意控制器传递数据（3）.$on()：监听事件与广播，可以捕获 $emit 和 $broadcast</code></pre><p>可以将控制器之间的通信，分为三种情形：<br>    （1）.无直接关联的控制器：使用 $rootScope.$emit()、$rootScope.$boardcast() 或 $scope.$emit来发出数据，通过 $rootScope.$on() 来获取数据<br>    （2）.父控制器到子控制器：父控制器使用 $scope.$boradcast() 来发送数据，子控制器通过 $scope.$on() 来获取数据<br>（3）.子控制器至父控制器：子控制器使用 $scope.$emit() 来发送数据，父控制器通过 $scope.$on() 来获取数据<br>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p><h3 id="详述-angular-的-“依赖注入”"><a href="#详述-angular-的-“依赖注入”" class="headerlink" title="详述 angular 的 “依赖注入”"></a>详述 angular 的 “依赖注入”</h3><p>依赖注入是一种软件设计模式，目的是处理代码之间的依赖关系，减少组件间的耦合。AngularJS 是通过构造函数的参数名字来推断依赖服务名称的，通过 toString() 来找到这个定义的 function 对应的字符串，然后用正则解析出其中的参数（依赖项），再去依赖映射中取到对应的依赖，实例化之后传入6、ng-if 跟 ng-show/hide 的区别有哪些？<br>第一点区别是， ng-if 在后面表达式为 true 的时候才创建这个 dom 节点， ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。<br>第二点区别是， ng-if 会（隐式地）产生新作用域， ng-switch 、 ng-include 等会动态创建一块界面的也是如此。</p><h3 id="factory、service-和-provider-是什么关系？"><a href="#factory、service-和-provider-是什么关系？" class="headerlink" title="factory、service 和 provider 是什么关系？"></a>factory、service 和 provider 是什么关系？</h3><p>把 service 的方法和数据放在一个对象里，并返回这个对象；通过构造函数方式创建 service，返回一个实例化对象；创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;headerlink&quot; title=&quot;基础部分&quot;&gt;&lt;/a&gt;&lt;center&gt;基础部分&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;一个优秀的前端开发人员需要具备哪些特质？&quot;&gt;&lt;a href=&quot;#一个优秀的前端开
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="面试" scheme="http://NicolasGui.github.io/categories/All/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="web前端" scheme="http://NicolasGui.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://NicolasGui.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>web前端面试题之vue</title>
    <link href="http://NicolasGui.github.io/2017/12/18/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bvue/"/>
    <id>http://NicolasGui.github.io/2017/12/18/web前端面试题之vue/</id>
    <published>2017-12-18T07:02:29.000Z</published>
    <updated>2017-12-18T09:48:39.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="请说下具体使用vue的理解？"><a href="#请说下具体使用vue的理解？" class="headerlink" title="请说下具体使用vue的理解？"></a>请说下具体使用vue的理解？</h3><p>答：<br>    1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。<br>    2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。<br>    3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。<br>    4、js的代码无形的规范，团队合作开发代码可阅读性更高</p><h3 id="你觉得哪些项目适合vue框架？"><a href="#你觉得哪些项目适合vue框架？" class="headerlink" title="你觉得哪些项目适合vue框架？"></a>你觉得哪些项目适合vue框架？</h3><p>答：<br>    1、数据信息量比较多的，反之类似企业网站就无需此框架了。<br>    2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。</p><h3 id="怎么理解MVVM模式的这些框架？"><a href="#怎么理解MVVM模式的这些框架？" class="headerlink" title="怎么理解MVVM模式的这些框架？"></a>怎么理解MVVM模式的这些框架？</h3><p>答：<br>    1、M就是Model模型层，存的一个数据对象。<br>    2、V就是View视图层，所有的html节点在这一层。<br>    3、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。</p><h3 id="PC端项目你会在哪些场景使用Vue框架？"><a href="#PC端项目你会在哪些场景使用Vue框架？" class="headerlink" title="PC端项目你会在哪些场景使用Vue框架？"></a>PC端项目你会在哪些场景使用Vue框架？</h3><p>答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。<br>    那么vue为什么解决这些问题呢？<br>        第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。<br>        第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。</p><h3 id="active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="active-class是哪个组件的属性？嵌套路由怎么定义？"></a>active-class是哪个组件的属性？嵌套路由怎么定义？</h3><pre><code>vue-router模块的router-link组件。</code></pre><h3 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h3><p>答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p><h3 id="vue-router有哪几种导航钩子"><a href="#vue-router有哪几种导航钩子" class="headerlink" title="vue-router有哪几种导航钩子"></a>vue-router有哪几种导航钩子</h3><pre><code>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</code></pre><h3 id="scss是什么？安装使用的步骤是？有哪几大特性？"><a href="#scss是什么？安装使用的步骤是？有哪几大特性？" class="headerlink" title="scss是什么？安装使用的步骤是？有哪几大特性？"></a>scss是什么？安装使用的步骤是？有哪几大特性？</h3><pre><code>预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loadercss的预编译。</code></pre><p>使用步骤：<br>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）<br>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss<br>第三步：还是在同一个文件，配置一个module属性<br>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”<br>有哪几大特性:<br>1、可以用变量，例如（$变量名称=值）；<br>2、可以用混合器，例如（）<br>3、可以嵌套</p><h3 id="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"><a href="#mint-ui是什么？怎么使用？说出至少三个组件使用方法？" class="headerlink" title="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"></a>mint-ui是什么？怎么使用？说出至少三个组件使用方法？</h3><p>基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper</p><h3 id="v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><a href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？" class="headerlink" title="v-model是什么？怎么使用？ vue中标签怎么绑定事件？"></a>v-model是什么？怎么使用？ vue中标签怎么绑定事件？</h3><p>答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click="doLog()"></p><h3 id="axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>axios是什么？怎么使用？描述使用它实现登录功能的流程？</h3><p>答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p><h3 id="axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？"><a href="#axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？" class="headerlink" title="axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？"></a>axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？</h3><p>axios.put(‘api/user/8′)呢？<br>跨域，添加用户操作，更新操作。</p><h3 id="什么是RESTful-API？怎么使用"><a href="#什么是RESTful-API？怎么使用" class="headerlink" title="什么是RESTful API？怎么使用?"></a>什么是RESTful API？怎么使用?</h3><p>答：是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete</p><h3 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h3><p>答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h3 id="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h3><p>答：一个model+view+viewModel框架，数据模型model，viewModel连接两个<br>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p><h3 id="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><a href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？" class="headerlink" title="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h3><p>答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）<br>钩子函数参数：el、binding</p><h3 id="说出至少4种vue当中的指令和它的用法？"><a href="#说出至少4种vue当中的指令和它的用法？" class="headerlink" title="说出至少4种vue当中的指令和它的用法？"></a>说出至少4种vue当中的指令和它的用法？</h3><p>答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p><h3 id="vue-router是什么？它有哪些组件？"><a href="#vue-router是什么？它有哪些组件？" class="headerlink" title="vue-router是什么？它有哪些组件？"></a>vue-router是什么？它有哪些组件？</h3><p>答：vue用来写路由一个插件。router-link、router-view</p><h3 id="导航钩子有哪些？它们有哪些参数？"><a href="#导航钩子有哪些？它们有哪些参数？" class="headerlink" title="导航钩子有哪些？它们有哪些参数？"></a>导航钩子有哪些？它们有哪些参数？</h3><p>答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p><h3 id="Vue的双向数据绑定原理是什么？或者问（vue-data是怎么实现的？）"><a href="#Vue的双向数据绑定原理是什么？或者问（vue-data是怎么实现的？）" class="headerlink" title="Vue的双向数据绑定原理是什么？或者问（vue data是怎么实现的？）"></a>Vue的双向数据绑定原理是什么？或者问（vue data是怎么实现的？）</h3><p>答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化<br>第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h3 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h3><p>：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。<br>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。<br>更新前/后：当data变化时，会触发beforeUpdate和updated方法。<br>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h3 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h3><p>答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。<br>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p><h3 id="你是怎么认识vuex的？"><a href="#你是怎么认识vuex的？" class="headerlink" title="你是怎么认识vuex的？"></a>你是怎么认识vuex的？</h3><p>答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p><h3 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h3><p>答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。<br>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p><h3 id="请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法？</h3><p>答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p><h3 id="vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？"><a href="#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？" class="headerlink" title="vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？"></a>vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</h3><p>答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {<br>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’<br>第三步：注入到vue的子组件的components属性上面,components:{smithButton}<br>第四步：在template视图view中使用，<smith-button>  </smith-button><br>问题有：smithButton命名，使用的时候则smith-button。</p><h3 id="聊聊你对Vue-js的template编译的理解？"><a href="#聊聊你对Vue-js的template编译的理解？" class="headerlink" title="聊聊你对Vue.js的template编译的理解？"></a>聊聊你对Vue.js的template编译的理解？</h3><p>答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）<br>详情步骤：<br>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。<br>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p><h3 id="vue响应式原理？"><a href="#vue响应式原理？" class="headerlink" title="vue响应式原理？"></a>vue响应式原理？</h3><h3 id="vue-router实现原理？"><a href="#vue-router实现原理？" class="headerlink" title="vue-router实现原理？"></a>vue-router实现原理？</h3><h3 id="为什么要选vue？与其它框架对比的优势和劣势？"><a href="#为什么要选vue？与其它框架对比的优势和劣势？" class="headerlink" title="为什么要选vue？与其它框架对比的优势和劣势？"></a>为什么要选vue？与其它框架对比的优势和劣势？</h3><h3 id="vuejs与angularjs以及react的区别？"><a href="#vuejs与angularjs以及react的区别？" class="headerlink" title="vuejs与angularjs以及react的区别？"></a>vuejs与angularjs以及react的区别？</h3><h3 id="vuex是用来做什么的？"><a href="#vuex是用来做什么的？" class="headerlink" title="vuex是用来做什么的？"></a>vuex是用来做什么的？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;请说下具体使用vue的理解？&quot;&gt;&lt;a href=&quot;#请说下具体使用vue的理解？&quot; class=&quot;headerlink&quot; title=&quot;请说下具体使用vue的理解？&quot;&gt;&lt;/a&gt;请说下具体使用vue的理解？&lt;/h3&gt;&lt;p&gt;答：&lt;br&gt;    1、使用vue不必担心布
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="tools" scheme="http://NicolasGui.github.io/categories/All/tools/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="vue" scheme="http://NicolasGui.github.io/tags/vue/"/>
    
      <category term="web前端" scheme="http://NicolasGui.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://NicolasGui.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="http://NicolasGui.github.io/2017/10/26/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://NicolasGui.github.io/2017/10/26/Hexo+Github搭建个人博客/</id>
    <published>2017-10-26T07:19:12.000Z</published>
    <updated>2017-11-29T11:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客驿站，本站是使用Hexo+Github基于基于Node.js的静态博客框架, 官方文档请参考<a href="https://hexo.io" target="_blank" rel="external">Hexo</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><h4 id="安装Node（基础环境）"><a href="#安装Node（基础环境）" class="headerlink" title="安装Node（基础环境）"></a>安装Node（基础环境）</h4><p><a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node官网</a>你可以根据不同平台系统选择你需要的Node.js安装包<br>注意：Linux上安装Node.js需要安装Python 2.6 或 2.7 ，不建议安装Python 3.0以上版本。</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>目的：把本地的hexo内容提交到github上去.首先去<a href="http://www.github.com" target="_blank" rel="external">GitHub</a>申请个人账号，以便后期用来做博客的远程创库、域名、服务器之类的，github账号不再啰嗦了,跟一般的注册账号差不多，方便起见，顺便配置SSH Keys</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>开始之前，先切换NPM源， 解释一下，NPM是随同 NodeJS 一起安装的包管理工具，我们经常使用它来下载第三方包到本地。<br>但在使用 NPM 过程很多人估计都知道，在国内下载第三方包的速度极其之慢。因此推荐使用淘宝 NPM 镜像，它是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 ，操作如下：<br>终端/CMD里面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p><p>如此一来就可以使用 cnpm 命令来安装模块了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install xxxx</div></pre></td></tr></table></figure></p><p>接下来开始安装Hexo，首先在你个人的workspace创建博客文件夹，如myblog<br>然后cd到myblog里安装Hexo：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>接下来执行init命令初始化你的hexo：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure></p><p>至此，安装工作顺利完成！myblog就是你以后写博客的目录，所有的操作都在里面进行。</p><h3 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure><h3 id="预览博客"><a href="#预览博客" class="headerlink" title="预览博客"></a>预览博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure><p>接下来在浏览器地址栏输入：localhost:4000回车就可以预览你的博客了</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div></pre></td></tr></table></figure><h3 id="托管到gitHub"><a href="#托管到gitHub" class="headerlink" title="托管到gitHub"></a>托管到gitHub</h3><h4 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h4><p>创建一个与自己用户名同名的repository<br>在自己Github主页右下角，创建一个新的repository。比如我的Github账号是NicolasGui，那么我应该创建的repository名字应该是NicolasGui.github.io。</p><h4 id="添加git配置"><a href="#添加git配置" class="headerlink" title="添加git配置"></a>添加git配置</h4><p>首先在主题的配置文件_config.yml里面添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: http://github.com/NicolasGui/NicolasGui.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p><p>repository：就是你的gitHub同名仓库的地址</p><h4 id="代码上传"><a href="#代码上传" class="headerlink" title="代码上传"></a>代码上传</h4><p>安装 hexo-deployer-git依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><p>然后使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure><p>此时你可以在浏览器地址栏输入 “用户名.github.io.git”来访问你的个人博客<br>(用户名：你gitHub的用户名)</p><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><h4 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h4><p>域名申请的途径非常多，建议使用<a href="http://www.aliyun.com" target="_blank" rel="external">阿里云</a>的，方便后期备案，在阿里云购买了域名之后，到域名管理中心进行域名解析，添加以下几条记录值：</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路(isp)</th><th>记录值</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>用户名.github.io</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>192.30.252.153</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>192.30.252.154</td></tr></tbody></table><p>接下来在public目录新建名为CNAME的文件，注意，没有后缀名<br>然后在CNAME文件里面填写你的域名，如：xxx.com   注意：不带www也不带http，只需要域名就好<br>接下来分别执行hexo g重新生成一下博客<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure></p><p>然后再上传到git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure></p><p>之后就可以使用域名访问你的个人博客了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到我的博客驿站，本站是使用Hexo+Github基于基于Node.js的静态博客框架, 官方文档请参考&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Quick
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="Hexo" scheme="http://NicolasGui.github.io/categories/All/Hexo/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="Hexo" scheme="http://NicolasGui.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="http://NicolasGui.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>前端常用开发工具</title>
    <link href="http://NicolasGui.github.io/2017/04/26/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://NicolasGui.github.io/2017/04/26/前端开发工具/</id>
    <published>2017-04-26T07:02:29.000Z</published>
    <updated>2017-11-29T11:44:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文分享了前端常用开发工具以及在开发/过程中常用软件，收费软件附带破解，免费且百度能下载的软件烦请自行百度下载</p><hr><h2 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h2><h3 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h3><ul><li>Webstrom</li><li>editplus</li><li>JDK1.7</li><li>adt-bundle</li><li>MindManager</li><li>Fireworks_cs6</li><li>Adobe Photoshop CC 2017</li><li>代码压缩工具</li><li>node6.10</li><li>颜色拾取器</li><li>xampp</li><li>topspeeder</li><li>AxureRP-Pro</li></ul><hr><h3 id="办公类"><a href="#办公类" class="headerlink" title="办公类"></a>办公类</h3><ul><li>wps</li><li>Microsoft Office 2016</li><li>pdf</li></ul><hr><h3 id="系统工具类"><a href="#系统工具类" class="headerlink" title="系统工具类"></a>系统工具类</h3><ul><li>Microsoft.framework4.0</li><li>winrar</li></ul><hr><p>百度网盘地址：<a href="https://pan.baidu.com/s/1jIaALZS" target="_blank" rel="external">点我</a> ,密码：9h7i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文分享了前端常用开发工具以及在开发/过程中常用软件，收费软件附带破解，免费且百度能下载的软件烦请自行百度下载&lt;/p&gt;
&lt;hr&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="tools" scheme="http://NicolasGui.github.io/categories/All/tools/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="web前端" scheme="http://NicolasGui.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发工具" scheme="http://NicolasGui.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用mac自带阿帕奇</title>
    <link href="http://NicolasGui.github.io/2017/02/24/%E4%BD%BF%E7%94%A8mac%E8%87%AA%E5%B8%A6%E9%98%BF%E5%B8%95%E5%A5%87/"/>
    <id>http://NicolasGui.github.io/2017/02/24/使用mac自带阿帕奇/</id>
    <published>2017-02-24T07:02:29.000Z</published>
    <updated>2017-11-29T11:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache对于前端程序员来说是必不可少的一款web服务器，Mac系统自身带了apache，可以直接用来搭建本地web服务器，配置过程相对比较简单，本文将做简要描述，开始吧</p><h3 id="启动Apache"><a href="#启动Apache" class="headerlink" title="启动Apache"></a>启动Apache</h3><p>mac是默认自动启动Apache的，判断mac是否启动了Apache很简单，浏览器地址栏输入<a href="http://127.0.0.1" target="_blank" rel="external">http://127.0.0.1</a>   回车即可，如果页面显示It works！证明ok，介绍几个常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apachectl start   //开启apache</div><div class="line"></div><div class="line">sudo apachectl restart   //重启apache</div><div class="line"></div><div class="line">sudo apachectl stop    //关闭apache:</div></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="更改work-space"><a href="#更改work-space" class="headerlink" title="更改work space"></a>更改work space</h4><p>Apache在Windows下默认work space为htdocs，在mac下有所区别，路径为：/Library/WebServer/Documents<br>因此我们需要把前端代码拷贝到该目录进行测试，但是该目录藏这么深在实际使用过程中显然是比较麻烦的，因此接下来我们通过修改阿帕奇主配置文件httpd.conf来指定work space，步骤如下：<br>mac配置文件目录为：/etc ，默认是隐藏的，因此咱们在终端里面执行：open /etc/apache2/  就可以打开Apache主目录，找到httpd.conf文件，使用文本编辑器打开该文件， 如果不想那么麻烦的话可以使用vi编辑，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/apache2/httpd.conf</div></pre></td></tr></table></figure><p>编辑以下内容，原本为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DocumentRoot <span class="string">"/Library/WebServer/Documents"</span></div><div class="line">&lt;Directory <span class="string">"/Library/WebServer/Documents"</span>&gt;</div></pre></td></tr></table></figure></p><p>修改为自定义目录，比如我改成根目录的sites文件夹，那就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DocumentRoot <span class="string">"/Users/用户名/Sites"</span></div><div class="line">&lt;Directory <span class="string">"/Users/用户名/Sites"</span>&gt;</div></pre></td></tr></table></figure></p><p>这样子的话我们就可以把Apache的work space更改到根路径下的sites了，需要注意的是，如果使用sudo vi /etc/apache2/httpd.conf命令打开，那么你需要先按一下i才能编辑，编辑完了以后按下esc，然后输入:wq回车就可以保存退出了</p><h4 id="更改默认端口"><a href="#更改默认端口" class="headerlink" title="更改默认端口"></a>更改默认端口</h4><p>跟更改默认工作空间一样的方式打开httpd.conf，找到Listen 80这一行，将80改为你需要的端口就好</p><h4 id="显示文件目录"><a href="#显示文件目录" class="headerlink" title="显示文件目录"></a>显示文件目录</h4><p>Apache在没有index的情况下默认不会显示文件目录，可以通过修改httpd.conf实现文件列表的展示，方便调试操作如下：<br>将httpd.conf里面Options FollowSymLinks Multiviews之后加上Indexes，修改之后为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Options FollowSymLinks Multiviews Indexes</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Apache对于前端程序员来说是必不可少的一款web服务器，Mac系统自身带了apache，可以直接用来搭建本地web服务器，配置过程相对比
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="mac" scheme="http://NicolasGui.github.io/categories/All/mac/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="mac" scheme="http://NicolasGui.github.io/tags/mac/"/>
    
      <category term="服务器" scheme="http://NicolasGui.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue-router插件</title>
    <link href="http://NicolasGui.github.io/2017/01/26/vue-router/"/>
    <id>http://NicolasGui.github.io/2017/01/26/vue-router/</id>
    <published>2017-01-26T07:02:29.000Z</published>
    <updated>2017-11-29T11:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>vue-router就是SPA（单页应用）的路径管理器。通俗的说，vue-router就是我们WebApp的链接路径管理系统。它跟前端的a标签区别是什么？因为我们用Vue做的是单页应用，就相当于只有一个主的index.html页面，所以你写的a标签是不起作用的，你必须使用vue-router来对路径进行管理。</p><h3 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue-router"></a>安装vue-router</h3><p>vue-router是一个插件，所以需要用npm来进行安装的。在命令行工具里面，进入你的项目目录，输入下面命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-router --save</div></pre></td></tr></table></figure></p><p>如果你是通过vue-cli构建项目时已经选择安装了vue-router，那就不需要重复安装。如果npm install vue-router –save安装比较慢的话，切换到淘宝镜像然后使用cnpm install vue-router –save，切换方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p><h3 id="vue-router文件解读"><a href="#vue-router文件解读" class="headerlink" title="vue-router文件解读"></a>vue-router文件解读</h3><p>安装完vue-router，我们先在src/router/路径下找到index.js文件，这个js就是路由的核心文件，打开<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span>   //引入Vue</div><div class="line">import Router from <span class="string">'vue-router'</span>  //引入vue-router</div><div class="line">import Hello from <span class="string">'@/components/Hello'</span>  //引入默认的Hello.vue组件</div><div class="line">import Test from <span class="string">'@/components/Test'</span>  //引入测试vue组件</div><div class="line"></div><div class="line">Vue.use(Router)  //全局使用Router</div><div class="line"> </div><div class="line"><span class="built_in">export</span> default new Router(&#123;//配置路由</div><div class="line">  routes: [              </div><div class="line">    &#123;                    //每一个对象代表一个路由</div><div class="line">      path: <span class="string">'/'</span>,         //链接路径</div><div class="line">      name: <span class="string">'Hello'</span>,     //路由名称，</div><div class="line">      component: Hello   //对应的组件模板</div><div class="line">    &#125;,&#123;</div><div class="line">      path:<span class="string">'/Test'</span>,</div><div class="line">      name:<span class="string">'Test'</span>,</div><div class="line">      component:Test</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>然后我们就可以在App.vue里面通过router-view来展示我们的组件内容</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>我们说router是做路径管理的，那么我们就可以通过router-link来控制组件的切换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=<span class="string">"组件路径"</span>&gt;链接内容&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><p>在这里解释一下，to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成  to=”/” ，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">   &lt;li&gt;&lt;router-link to=<span class="string">"/"</span>&gt;首页&lt;/router-link&gt;&lt;/li&gt;</div><div class="line">   &lt;li&gt;&lt;router-link to=<span class="string">"/Test"</span>&gt;Test页面&lt;/router-link&gt;&lt;/li&gt;   </div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;vue-router就是SPA（单页应用）的路径管理器。通俗的说，vue-router就是我们WebApp的链接路径管理系统。它跟前端的a标
      
    
    </summary>
    
      <category term="All" scheme="http://NicolasGui.github.io/categories/All/"/>
    
      <category term="vue" scheme="http://NicolasGui.github.io/categories/All/vue/"/>
    
    
      <category term="All" scheme="http://NicolasGui.github.io/tags/All/"/>
    
      <category term="vue" scheme="http://NicolasGui.github.io/tags/vue/"/>
    
      <category term="web前端" scheme="http://NicolasGui.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="路由" scheme="http://NicolasGui.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
</feed>
